#include <linux/kernel.h>
#include <linux/init.h>
#include <linux/module.h>
#include <linux/kdev_t.h>
#include<linux/types.h>
#include<linux/kdev_t.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/device.h>
#include <linux/uaccess.h>              	 //for copy_to/from_user()
#include <linux/ioctl.h>		 	 //for ioctl calls
#include<linux/slab.h>
#include<linux/errno.h> 	
#include <linux/random.h>		 	 //for generating random function

#define NUMBER 'A'				/**********************************************************************************/
#define ADC_1 _IOW (NUMBER, 0, int32_t*)	/* These macros will contain request number					    */
#define ADC_2 _IOW (NUMBER, 1, int32_t*)	/* using _IOW to generate request number with write fuctionality only	   */
#define ADC_3 _IOW (NUMBER, 2, int32_t*)	/* ADC_1 used fo channel number, ADC_2 for allignment, ADC_3 for mode selcrtion*/

   
static dev_t adc_dev;					/*********************************************************************/
static struct class *adc_cls;				/* variable channel can take vlaue 0 to 7                             */      
static struct cdev c_dev;				/* variable allignment 0= right alligned, 1= left alligned            */
							/* variable conv_mode 0= single, 1= continuous                        */
							/**********************************************************************/

uint32_t channel, allignment,conv_mode;      // These variables will contain the data transferred from user 
uint16_t data;				       /* data variable will contain the output generated by ADC*/



//********************************** This will be called when user open the device ******************************
static int adc_open(struct inode *i, struct file *f)
{
	printk(KERN_INFO "adc is open now\n");
	return 0;
}

//*********************************** This will be called when user close the device ****************************
static int adc_close( struct inode *i, struct file *f)
{
	printk(KERN_INFO " adc is close now\n");
	return 0;
}



//************************************ This will be called when we try to read data from ADC ***********************
static ssize_t adc_read (struct file *f, char __user *buf, size_t len, loff_t *off)
{
	printk(KERN_INFO "reading data from ADC\n");
	
	
	
	
	
		get_random_bytes(&data, 2);
		//random bit will get stored in variable 'data'
		/* Using bitwise AND operation to make the ADC output left or right oriented */
		if(allignment ==1)
		{
			printk(KERN_INFO "sit back getting lower 12 bit for you\n");
			data = (data & 0x0FFF);
			printk(KERN_INFO " data recieved from ADC is %d\n",data);
			copy_to_user(buf, &data,2);
		}
		
		else
		if (allignment ==0)
		{
			printk(KERN_INFO "sit back getting upper 12 bit for you\n");
			data = (data & 0xFFF0);
			printk(KERN_INFO " data recieved from ADC is %d\n",data);
			copy_to_user(buf, &data,2);
		}
		
			
	
	return 0;
}

/************************** adc_ioctl is will be called when user make ioctl system call  *******************************/
static long int adc_ioctl (struct file *f, unsigned int request_no, long unsigned int parameter)
{
	switch (request_no)
	{
		case ADC_1 :
			copy_from_user (&channel, (int32_t*) parameter, sizeof (channel));
			printk (KERN_INFO " The ADC channel is %d\n", channel);
			break;
		
		case ADC_2 :
			copy_from_user (&allignment, (int32_t*) parameter, sizeof(allignment));
			printk (KERN_INFO "ADC output allignment %d selected\n", allignment);
			break;
		
		case ADC_3 :
			copy_from_user (&conv_mode, (int32_t*) parameter, sizeof(conv_mode));
			printk(KERN_INFO "ADC conversion mode %d selected\n", conv_mode);
			break;
	}
	return 0;
}
		
	
	





//*********************************** File Operation structure **********************************************
static struct file_operations fops=
{
    .owner   =   THIS_MODULE, 
    .open    =   adc_open,			/*using open, close, read fuctionality                   */
    .release =   adc_close,			/*using IOCTL for data transfer from user to kernel space*/
    .read    =   adc_read,
    .unlocked_ioctl = adc_ioctl
};





// ********************************** Intialization function ***********************************************
static int __init adc_driver_init(void)
{
	//************************** allocating major and minor number dynamically ************************
	
	if((alloc_chrdev_region(&adc_dev, 0, 1, "adc-dev")) < 0) // alloc_chrdev_region used to dynamically allocate major and minor number
	{
		printk(KERN_INFO "issue in allocating major number\n");
		return -1;
	}
	printk(KERN_INFO "Major = %d Minor = %d \n",MAJOR(adc_dev), MINOR(adc_dev));		
	
	//**************************** creating class for device *****************************************
	if((adc_cls= class_create(THIS_MODULE,"etx_class")) == NULL)
	{
		printk(KERN_INFO "Issue in creating class\n");
		unregister_chrdev_region(adc_dev,1);
		return -1;
	}
	
	printk (KERN_INFO "Class created\n" );
	//**************************** creatng device ******************************************************
	if((device_create(adc_cls,NULL,adc_dev,NULL,"adc-dev")) == NULL)	
	{
		printk(KERN_INFO "Issue in creating device\n");
		class_destroy(adc_cls);
		unregister_chrdev_region(adc_dev,1);
      		return -1;	
      	}
      	printk(KERN_INFO "Device created\n");
      	
      	//*************************** intialiazing char dev ************************************************
      	cdev_init(&c_dev,&fops);
      	
      	
      	
      	//**************************** loading character device to the system ******************************
      	
      	 if((cdev_add(&c_dev,adc_dev,1)) < 0)
      	 {
      	 	printk(KERN_INFO "Not able to loat device to the system\n");
      	 	cdev_del(&c_dev);
        	device_destroy(adc_cls,adc_dev);
        	class_destroy(adc_cls);
      		unregister_chrdev_region(adc_dev, 1);
        	return -1;
        }
        printk (KERN_INFO "ADC is ready for service now\n");
        
        return 0;
}


static void __exit adc_driver_exit(void)
{
	cdev_del(&c_dev);
        device_destroy(adc_cls,adc_dev);
        class_destroy(adc_cls);
        unregister_chrdev_region(adc_dev, 1);
        printk(KERN_INFO "ADC driver removed\n");
        
}


module_init (adc_driver_init);
module_exit(adc_driver_exit);
MODULE_LICENSE("GPL");








